---
title: 2020-2-11维文显示解决方案
tags: 维文,图片
grammar_cjkRuby: true
---

一、维文生成困难原因
	维文字符依次输入后，从右往左显示和字符在不同位置变换的特殊性
    
二、解决方案
	（2020.02.11）尝试解决方案之一：
    根据阿拉伯文的Unicode编码，将字符全部生成点阵信息。
    1. 维文规则: 根据位置的不同，维文可分为前连式、后连式、双连式、独立体这四大类，并且根据字符的位置进行变形。
    2. 维文的四类，分别对应（first，last，middle，alone）这四个数组集合：
  const WORD Arbic_Position[][4]=  // first, last, middle, alone
  {{ 0xfe80, 0xfe80, 0xfe80, 0xfe80},    // 0x621
  { 0xfe82, 0xfe81, 0xfe82, 0xfe81},
  { 0xfe84, 0xfe83, 0xfe84, 0xfe83},
  { 0xfe86, 0xfe85, 0xfe86, 0xfe85},
  { 0xfe88, 0xfe87, 0xfe88, 0xfe87},
  { 0xfe8a, 0xfe8b, 0xfe8c, 0xfe89},
  { 0xfe8e, 0xfe8d, 0xfe8e, 0xfe8d},
  { 0xfe90, 0xfe91, 0xfe92, 0xfe8f},   // 0x628
  { 0xfe94, 0xfe93, 0xfe94, 0xfe93},
  { 0xfe96, 0xfe97, 0xfe98, 0xfe95},   // 0x62A
  { 0xfe9a, 0xfe9b, 0xfe9c, 0xfe99},
  { 0xfe9e, 0xfe9f, 0xfea0, 0xfe9d},
  { 0xfea2, 0xfea3, 0xfea4, 0xfea1},
  { 0xfea6, 0xfea7, 0xfea8, 0xfea5},
  { 0xfeaa, 0xfea9, 0xfeaa, 0xfea9},
  { 0xfeac, 0xfeab, 0xfeac, 0xfeab},   // 0x630  
  { 0xfeae, 0xfead, 0xfeae, 0xfead},
  { 0xfeb0, 0xfeaf, 0xfeb0, 0xfeaf},
  { 0xfeb2, 0xfeb3, 0xfeb4, 0xfeb1},
  { 0xfeb6, 0xfeb7, 0xfeb8, 0xfeb5},
  { 0xfeba, 0xfebb, 0xfebc, 0xfeb9},
  { 0xfebe, 0xfebf, 0xfec0, 0xfebd},
  { 0xfec2, 0xfec3, 0xfec4, 0xfec1},
  { 0xfec6, 0xfec7, 0xfec8, 0xfec5},  // 0x638
  { 0xfeca, 0xfecb, 0xfecc, 0xfec9},
  { 0xfece, 0xfecf, 0xfed0, 0xfecd},  //0x63A
  { 0x63b, 0x63b, 0x63b, 0x63b},
  { 0x63c, 0x63c, 0x63c, 0x63c},
  { 0x63d, 0x63d, 0x63d, 0x63d},
  { 0x63e, 0x63e, 0x63e, 0x63e},
  { 0x63f, 0x63f, 0x63f, 0x63f},
  { 0x640, 0x640, 0x640, 0x640},   // 0x640
  { 0xfed2, 0xfed3, 0xfed4, 0xfed1},
  { 0xfed6, 0xfed7, 0xfed8, 0xfed5},
  { 0xfeda, 0xfedb, 0xfedc, 0xfed9},
  { 0xfede, 0xfedf, 0xfee0, 0xfedd},
  { 0xfee2, 0xfee3, 0xfee4, 0xfee1},
  { 0xfee6, 0xfee7, 0xfee8, 0xfee5},
  { 0xfeea, 0xfeeb, 0xfeec, 0xfee9},
  { 0xfeee, 0xfeed, 0xfeee, 0xfeed},   // 0x648
  { 0xfef0, 0xfef3, 0xfef4, 0xfeef},
  {0xfef2, 0xfef3, 0xfef4, 0xfef1},   // 0x64A
  };


3.判断是否是连接前面的方法：判定该字符前一个字符，前一个字符如果在集合set1中，则是有连接前面的。
	集合1:
    static U16 theSet1[23]={
        0x62c， 0x62d， 0x62e， 0x647， 0x639， 0x63a， 0x641， 0x642，
        0x62b， 0x635， 0x636， 0x637， 0x643， 0x645， 0x646， 0x62a，
        0x644， 0x628， 0x64a， 0x633， 0x634， 0x638， 0x626, 0x640};  // 0x640 新增

4.判断是否是连接后面的方法：判定该字符后一个字符，后一个字符如果在集合set2中，则是有连接后面的。
	集合2如下:
    static U16 theSet2[35]={
        0x62c， 0x62d， 0x62e， 0x647， 0x639， 0x63a， 0x641， 0x642，
        0x62b， 0x635， 0x636， 0x637， 0x643， 0x645， 0x646， 0x62a，
        0x644， 0x628， 0x64a， 0x633， 0x634， 0x638， 0x626，
        0x627， 0x623， 0x625， 0x622， 0x62f， 0x630， 0x631， 0x632，
        0x648， 0x624， 0x629， 0x649, 0x640};   // 0x640 新增
        
5.举例
例1： 0x064A， 0x0644， 0x0622
      0x064A 的后面一个字符 0x0644 在集合2中，根据编码规则1得出它是后连字符（last），故转换成: 0xFEF3.  
      而0x064A在集合1 中，故用 0xFEF6 替代 0x0644 0x0622 这两个编码。     
       
例2： 0x0632， 0x0644， 0x0622
      0x0632 的后面一个字符 0x0644 在集合2中，根据编码规则1得出它是后连字符 （last）， 故转换成: 0xFEAF.  
      而 0x0632 不在集合1 中，故用 0xFEF5 替代 0x0644 0x0622 这两个编码。

6. 解决流程：
用FreeType渲染矢量字形
>> 原始字符串 >> 解析模块(处理原始Unicode码)
>> 处理后Unicode码串 >> 渲染模块(根据Unicode码取字模并合成点阵数组)
>> 点阵数组 >> 显示

（2020.02.11）尝试解决方案之二：
强行转换字符串顺序显示